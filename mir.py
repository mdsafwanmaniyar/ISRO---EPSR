# -*- coding: utf-8 -*-
"""MIR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1awVWRO5YONlxaQJeJyGQKf2lRCMbJd21
"""

! pip install keras

! pip install huggingface_hub

import numpy as np # array manipulation
from huggingface_hub import from_pretrained_keras # download the model
import keras # deep learning
from PIL import Image # Image processing
import os
import numpy as np
import cv2
from glob import glob
import tensorflow as tf
from tensorflow.keras.layers import Conv2D, BatchNormalization, Activation, MaxPool2D, Conv2DTranspose, Concatenate
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint, ReduceLROnPlateau, CSVLogger

model = from_pretrained_keras("keras-io/lowlight-enhance-mirnet", compile=False)

# Define the Physics-Based Enhancement Layer
class PhysicsEnhancementLayer(tf.keras.layers.Layer):
    def _init_(self, albedo_map, exposure_time, iso, temperature, **kwargs):
        super(PhysicsEnhancementLayer, self)._init_(**kwargs)
        self.albedo_map = albedo_map
        self.exposure_time = exposure_time
        self.iso = iso
        self.temperature = temperature

    def call(self, inputs):
        # Illumination Compensation
        enhanced_brightness = self.apply_illumination(inputs)
        # Surface Reflectance Adjustments using BRDF
        reflectance_adjusted = self.apply_brdf(enhanced_brightness, self.albedo_map)
        # Noise Reduction
        noise_reduced = self.reduce_noise(reflectance_adjusted, self.exposure_time, self.iso, self.temperature)
        return noise_reduced

    def apply_illumination(self, inputs):
        # Simulate Earthshine for brightness correction
        return tf.math.multiply(inputs, 1.2)  # Adjust factor based on lunar conditions

    def apply_brdf(self, inputs, albedo_map):
        # Apply the BRDF reflectance model
        return inputs * albedo_map

    def reduce_noise(self, inputs, exposure_time, iso, temperature):
        # Noise reduction based on camera parameters
        noise_factor = 1 / (exposure_time * iso + temperature)
        return tf.math.multiply(inputs, noise_factor)

# Function to enhance the lunar image
def enhance_lunar_image_with_physics(image, albedo_map, exposure_time, iso, temperature):
    # Normalize the input image
    image = image.astype('float32') / 255.0
    image = np.expand_dims(image, axis=0)

    # Apply MIRNet model
    mirnet_output = model.predict(image)

    # Apply Physics-Based Post-Processing
    physics_layer = PhysicsEnhancementLayer(albedo_map, exposure_time, iso, temperature)
    enhanced_image = physics_layer(mirnet_output)

    return enhanced_image# Read the image from the request (coming from the frontend form submission)
#image_file = request.files['image']  # 'image' is the name attribute from the form
# Convert the uploaded file to an image
low_light_img = Image.open('/content/9.png').convert('RGB')

low_light_img

low_light_img = low_light_img.resize((256,256),Image.NEAREST)

low_light_img

image = keras.preprocessing.image.img_to_array(low_light_img)

image.shape

image = image.astype('float32') / 255.0

image = np.expand_dims(image, axis = 0)

image.shape

output = model.predict(image)

output_image = output[0] * 255.0

output_image = output_image.clip(0,255)

output_image = output_image.reshape((np.shape(output_image)[0],np.shape(output_image)[1],3))

output_image

output_image = np.uint32(output_image)

Image.fromarray(output_image.astype('uint8'),'RGB')

# Save the pre-trained model to an .h5 file
model.save('lowlight_enhance_mirnet.h5')

from tensorflow import keras
from PIL import Image
import tensorflow as tf
import numpy as np

# Load the pretrained MIRNet model from Keras
model = keras.models.load_model('path_to_pretrained_mirnet.h5', compile=False)

# Define the Physics-Based Enhancement Layer
class PhysicsEnhancementLayer(tf.keras.layers.Layer):
    def _init_(self, albedo_map, exposure_time, iso, temperature, **kwargs):
        super(PhysicsEnhancementLayer, self)._init_(**kwargs)
        self.albedo_map = albedo_map
        self.exposure_time = exposure_time
        self.iso = iso
        self.temperature = temperature

    def call(self, inputs):
        # Illumination Compensation
        enhanced_brightness = self.apply_illumination(inputs)
        # Surface Reflectance Adjustments using BRDF
        reflectance_adjusted = self.apply_brdf(enhanced_brightness, self.albedo_map)
        # Noise Reduction
        noise_reduced = self.reduce_noise(reflectance_adjusted, self.exposure_time, self.iso, self.temperature)
        return noise_reduced

    def apply_illumination(self, inputs):
        # Simulate Earthshine for brightness correction
        return tf.math.multiply(inputs, 1.2)  # Adjust factor based on lunar conditions

    def apply_brdf(self, inputs, albedo_map):
        # Apply the BRDF reflectance model
        return inputs * albedo_map

    def reduce_noise(self, inputs, exposure_time, iso, temperature):
        # Noise reduction based on camera parameters
        noise_factor = 1 / (exposure_time * iso + temperature)
        return tf.math.multiply(inputs, noise_factor)

# Function to enhance the lunar image
def enhance_lunar_image_with_physics(image, albedo_map, exposure_time, iso, temperature):
    # Normalize the input image
    image = image.astype('float32') / 255.0
    image = np.expand_dims(image, axis=0)

    # Apply MIRNet model
    mirnet_output = model.predict(image)

    # Apply Physics-Based Post-Processing
    physics_layer = PhysicsEnhancementLayer(albedo_map, exposure_time, iso, temperature)
    enhanced_image = physics_layer(mirnet_output)

    return enhanced_image

# Read the image from the request (coming from the frontend form submission)
image_file = request.files['image']  # 'image' is the name attribute from the form

# Convert the uploaded file to an image
low_light_img = Image.open(image_file).convert('RGB')
low_light_img = low_light_img.resize((256, 256), Image.NEAREST)

# Convert to array
image = keras.preprocessing.image.img_to_array(low_light_img)

# Example parameters for the physics-based layer
albedo_map = np.ones((256, 256, 3))  # Example albedo map
exposure_time = 30  # Exposure time in seconds
iso = 1600  # ISO of the camera
temperature = -100  # Temperature in Celsius

# Apply MIRNet and Physics-Based Post-Processing
enhanced_image = enhance_lunar_image_with_physics(image, albedo_map, exposure_time, iso, temperature)

# Convert the processed image back to display format
enhanced_image = (enhanced_image.numpy().squeeze() * 255).astype(np.uint8)
enhanced_image_pil = Image.fromarray(enhanced_image)

# Save the output or send it back to the frontend
enhanced_image_pil.save('enhanced_lunar_image.png')